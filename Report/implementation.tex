\subsection{Theoretical Background}
The only background needed for this extension is knowing the tool's AST and the C language.
However since we are trying to emulate an object-oriented language into one that is not,
the book ``Object-oriented programming in ANSCI-C''\footnote{https://www.cs.rit.edu/~ats/books/ooc.pdf}
by Axel Schreiner has been useful for some concepts and it will be referenced throughout this report.

\subsection{Implementation Details}
Two files were created to implement this project.
\subsubsection{Data Type}
The first one is \say{CDataType.scala}. It contains a class that depicts the C's structure.
\lstset{style=customscala}
\begin{lstlisting}
  class StructDef(val name: String,
    val membersList: ListBuffer[StructMember])
\end{lstlisting}
 A trait \say{StructMember} is extended by two classes to implement the two kinds of structure's members,
 which are a variable or a pointer to a function (as explained in section 2. Examples).
 The pointer to a function holds two fields, one for an internal representation of a C function pointer (the class \say{FunctionPtr}),
 and one for the AST version of the method declaration that should be linked to the pointer.

 \begin{lstlisting}
class StructVar(val name: String,
  val tpe: CType) extends StructMember {
  // some code
}

class StructFunctionPtr(val ptr: FunctionPtr,
  var mtDcl: MethodDecl) extends StructMember {
  // some code
}

class FunctionPtr(val name: String,
  val retType: CType, val args: List[CType]) {
  // some code
}
 \end{lstlisting}
 \subsubsection{Code Generation}
The second file is \say{COutputGeneration.scala}. Its skeleton and behavior is based on the \say{CodeGeneration.scala} completed
to output binary code for the Java Virtual Machine.
The program uses the same architecture of methods like: \say{cGenMethod}, \say{cGenStats}, \say{cGenExpr}.
Each of this method returns a \lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|StringBuilder|}.
\newline
The final is a .h and .c, which encloses all the StringBuilders concatened.
\newline
\paragraph{Overview}
The main method of the object
\newline
\lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|COutputGeneration|} is
\lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|def run(ctx: Context)(prog: Program)|}, which takes
in parameter the AST of the code. % TODO correct?!
\newline
The method starts by creating a \lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|StringBuilders|} for the preprocessor directives.
It includes the headers \lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|stdio.h, string.h and stdlib.h|}.
It contains \lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|#define INT_MAX_LENGTH 12|}, which is useful
in order to have correct Int to string of characters concatenation.
It also encloses the definition of default constructor for every classes of the program.
\begin{lstlisting}[caption={In the case of the example used in section 2. Examples}, captionpos=b]
#define nAnimal 0
#define nDog 1
\end{lstlisting}
Finally, a \lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|StringBuilder|} contains the inclusion of the file's header,
which is directly created.
\newline
Afterward a method takes care of generating the structures corresponding to the Tool's classes:
\newline
\lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|def genStructDef(ct: ClassDecl): StructDef|}.
The method takes as parameters a \lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|ClassDecl|}
and returns a corresponding \lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|StructDef|},
which was presented in section 3.2.1 Data Type. Then the \lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|StructDef|}'s method
\lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|toStringRepr|} to return the structures as String.
\newline
Thereafter the method manages the program's methods.
\begin{lstlisting}
def genMethods(ct: ClassDecl): StringBuilder =
        (for(mt <- ct.methods)yield(cGenMethod(ct, mt))).foldLeft(new StringBuilder())((a,b) => a append b)
\end{lstlisting}
The method \lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|cGenMethod|} traverses the AST node
\lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|MethodDecl|} to translate the statements and the expressions
in C programming language, using the methods \lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|cGenStats|} and
\lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|cGenExpr|} like in the Code Generation lab.
The method returns a \lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|StringBuilder|}
representing a function, that corresponds to a Tool's class method.
\newline
Then the Tool's main method is translated into C programming language.
\begin{lstlisting}
def genMainMethod(main: MainObject): StringBuilder = {
  val mainMethod = new StringBuilder("int main(void){\n")
  main.stats.foldLeft(mainMethod)((sB, stmt) => sB append(cGenStat(stmt)(1, None)))
  return mainMethod.append("\treturn 0;\n}")
    }
\end{lstlisting}
The \lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|genMainMethod|} method receives
as parameter the AST node \lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|MainObject|}.
It is converted as the \lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|main|} function in C programming language.
\begin{lstlisting}
int main(void){
  return 0;
}
\end{lstlisting}
\lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|MainObject|} contains
a list of \lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|StatTree|}.
Each \lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|StatTree|} is evaluated
by the method \lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|cGenStat|} and
the returned \lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|StringBuilder(s)|}
are the body of the C \lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|main|} function.
\newline
In the \lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|run|} method, there exists
an object
\newline
\lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|defaultConstructor|}.
It represents the construction of the default constructor. The function is called
\lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|new|}.
The function takes as parameter an integer. It is one of the defined integer for each Tool's class,
that we have seen before. % TODO faudrait-il les afficher de nouveau??
Subsequently a method \lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|addStructConstructor|}
takes care of adding a \lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|case|} element
to the \lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|new|} function for a correct
initialization of a Tool's object in C programming language.
\begin{lstlisting}[caption={In the case of the example used in the section 2. Examples}, captionpos=b]
void * new(int type){
  void * object;
  switch(type){
    case nAnimal:
      object = malloc(sizeof(struct Animal));
      ((struct Animal *) object)->sleep = Animal_sleep;
      break;
    case nDog:
      object = malloc(sizeof(struct Dog));
      ((struct Dog *) object)->bark = Dog_bark;
      ((struct Dog *) object)->sleep = Dog_sleep;
    default:
      return NULL;
  }
  return object;
}
\end{lstlisting}
At the end, the functions
\newline
\lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|void helper_reverse_plus(char str[], int len)|},
\lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|char* itoa(int num)|} and
\lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|int * arrayAlloc(int size)|} are constructed.
Their usefulness will be explained in the subsections to come.
\newline
Finally all these snippet of C code are concatenated and written in a .c file.
\newline
\paragraph{Dynamic dispatch}
Dynamic dispatch is accomplished during the default construction of a new Instance of a class.
In Tool, there is only on type of constructor, the default one.
One idea we borrowed from our reference book\footnote{www.cs.rit.edu/~ats/books/ooc.pdf at page 11, si jamais faudra mettre ca dans la bibliography Ã  la fin scuse} was to have a default method be outputed called ``new'' which would take care or creating a new Instance of a struct and returning it as a generic pointer ``void *''. This function was already presented in the overview.\\

And according to the overriding of the methods or not, this method also takes care of setting the value of the struct's function pointers to the corresponding function. To be sure that calling {\lstinline[basicstyle=\small\ttfamily]|sleep|} on an instance of Animal will get the correct pointer, for inherited structs, we make sure they hold the same fields in the same place than their parent struct. If we look at the struct definitions of example 2, we clearly see that the function pointer {\lstinline[basicstyle=\small\ttfamily]|sleep|} is held in the same place in both structs. Therefore, if we consider this Tool code snippet :

\lstset{style=customtool}
\begin{lstlisting}
program Sleep{
  println(new Farm().getPet(0).sleep());
  //prints ``zzz...''
  println(new Farm().getPet(1).sleep());
  //prints ``zzz... wouaf... zzz...''
}

class Farm{
  def getPet(sel: Int): Animal = {
    if(sel == 0){
      return new Animal();
    }else{
      return new Dog();
    }
  }
}
\end{lstlisting}
Running it will result with the sleep message of animal printed and followed by the sleep message of a dog. This is an exemple of dynamic dispatch. Using casting, then the same result can be obtained in C :

\lstset{style=customc}
\begin{lstlisting}
int main(void){
  void * farm0 = new(nFarm)
  void * animal0 = ((struct Farm *)farm0)->getPet(0);
  printf("\%s\\n", ((struct Animal *) animal1)->sleep())
  //prints ``zzz...''
  void * farm1 = new(nFarm)
  void * animal1 = ((struct Farm *)farm1)->getPet(1);
  printf("\%s\\n", ((struct Animal *) animal1)->sleep())
  //prints ``zzz... wouaf... zzz...''
}
\end{lstlisting}

Casting to Animal is made in both case because {\lstinline[basicstyle=\small\ttfamily]|getPet|} returns an instance of Animal so the compiler treat the value returned to be of type ``Animal''. Even if a Dog is returned it will use the {\lstinline[basicstyle=\small\ttfamily]|sleep|} function of the dog since the pointer to {\lstinline[basicstyle=\small\ttfamily]|sleep|} in Dog's struct is in the same place as the one of Animal's struct.

\paragraph{Length of Arrays}
Another problem encountered was retrieving an array's length. In Tool, getting it is made in the same way as Java, by accessing the field {\lstinline[basicstyle=\small\ttfamily]|length|} of the array. However this cannot be translated easily in C if the array is not statically allocated. The way we treat arrays of ints in our extension is by defining them as a pointer to a value of type int. Then creating a new array of n elements is made by using calloc with n and {\lstinline[basicstyle=\small\ttfamily]|sizeof(int)|} as arguments. The pointer returned points now to a region of the memory that can hold n ints. We will call this pointer ``x''. And since our array is juste a pointer, trying the trick of {\lstinline[basicstyle=\small\ttfamily]|sizeof(x) / sizeof(int)|} to get its length will either be equal to 1 or 2 (depending on the system word size) because {\lstinline[basicstyle=\small\ttfamily]|sizeof(x)|} in this case return the size of the pointer, not the size of the memory this pointer was allocated to.\\
To resolves this problem, we defined an helper function called {\lstinline[basicstyle=\small\ttfamily]|arrayAlloc|} printed with every program.

\begin{lstlisting}
int * arrayAlloc(int size){
  int * smrtArray = calloc(size + 1, sizeof(int));
  smrtArray[0] = size;
  return (smrtArray + 1);
}
\end{lstlisting}

What this function does is pretty simple but ingenious. The array is callocated for one more element than the size required, and then the length of this array is stocked at the first place of the callocated array. We return then the value of the pointer incremented by one. Thus, when we need to get the length of the array ``x'', we can get it from the value hold at the place ``-1'' of the pointer ``x''

\begin{lstlisting}
int * x = arrayAlloc(42);
int xLength = *(x - 1) //xLength is equal to 42.
\end{lstlisting}

\paragraph{Concatenation}
The AST node \say{Plus} asked for some attention.
The Tool language allows to apply the \say{+} operator on Int and String operands.
\newline
The situation, where the two operands are Int, is straightforward to emulate in C programming language.
It's also an addition.
\newline
The event where the two operands are String is a little bit more tricky.
It is necessary to allocate memory before concatenate the two string of characters.
\begin{lstlisting}
strcpy(malloc(strlen("+ lhsString +") + strlen(" + rhsString +") + 1)," +
                lhsString +")," + rhsString +")"
\end{lstlisting}
Finally when the two operands are different, we were obliged to create two C functions:
\newline
\lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|void helper_reverse_plus(char str[], int len)|} and
\lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|char* itoa(int num)|}.
These functions transform an integer into a string of characters and return it.
\newline
These two functions are written in every .c file generated by the compiler.
\newline
\paragraph{Method chaining}
\break
This problem was one, that we had not seen coming.
\newline
In Tool, there is the possibility to write multiple call to a method on one line.
It works because each method returns an object.
We can't directly translate it in C programming language with the model we choosed to make object oriented possible.
Our ``methods'' need to have as a first argument a pointer to the struct calling,
so to make a method call on a struct we would need to write : \lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|void * a = new(nA); ((struct A *) a)->foo(a)|}.
Our variable a needs to be referenced two times, first to get the good function pointer and then as the first argument if ``foo'' need to access fields defined in A.
Therefore chained method calls need intermediate variables to work correctly.
To tackle this problem, we created a simple object: \say{tmpVarGen}.
\lstset{style=customscala}
\begin{lstlisting}
object tmpVarGen{
  private var counter = 0
  private var lastSuffix = ""
  def getFreshVar(suffix: Option[String]): String = {
    counter += 1
    val sffx = suffix match{
      case Some(s) => s
      case None => ""
    }
    lastSuffix = sffx
    return "tmp"+sffx+counter
  }
  def getLastVar: String = "tmp"+lastSuffix+counter
}
\end{lstlisting}
It is used to have a unique variable name. It has two methods.
\say{getLastVar} returns the last created variable name.
\say{getFreshVar} return a new variable name.
\newline
Now at each evaluation of an AST node, which is an expression, it is important first to evaluate the expressions
and assign to intermediate variables using the object \say{tmpVarGen}. Next the expression is written using
the variables.
\begin{lstlisting}
case Equals(lhs: ExprTree, rhs: ExprTree) =>
  val lhsString = cGenExpr(lhs)
  val lhsLastVar = tmpVarGen.getLastVar
  val rhsString = cGenExpr(rhs)
  val rhsLastVar = tmpVarGen.getLastVar
  val andExprResultVar = genTabulation(indentLvl)+
    CInt.toString()+" "+tmpVarGen.getFreshVar+" = "+
    lhsLastVar+" == "+rhsLastVar+";\n"
  return lhsString.append(rhsString).append(andExprResultVar)
\end{lstlisting}
Here it is an example with the evaluation of an expression AST node: Equals.
The left-hand side and right-hand side expressions are first evaulated using the \say{cGenExpr()} method and
are stored in intermediate variable using the \say{tmpVarGen} object.
Afterward the equal expression as known in C: \say{lhs == rhs} is written using the intermediate variable.
At the end we append all element together. Thus one Tool line to write an equality is
three lines in C programming language.
\newline
