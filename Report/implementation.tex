This is a very important section, you explain to us how you made it work.

\subsection{Theoretical Background}
The only background needed for this extension is knowing the tool's AST and the C language. However since we are trying to emulate an object-oriented language into one that is not, the book ``Object-oriented programming in ANSCI-C''\footnote{https://www.cs.rit.edu/~ats/books/ooc.pdf} by Axel Schreiner has been useful for some concepts and it will be referenced throughout this report.

\subsection{Implementation Details}
Two files were created to implement this project.
\subsubsection{Data Type}
The first one is \say{CDataType.scala}. It contains a class that depicts the C's structure.
\lstset{style=customscala}
\begin{lstlisting}
  class StructDef(val name: String,
    val membersList: ListBuffer[StructMember])
\end{lstlisting}
 A trait \say{StructMember} is extended by two classes to implement the two kinds of structure's members,
 which are a variable or a pointer to a function (as explained in section 2. Examples). The pointer to a function holds two fields, one for an internal representation of a C function pointer (the class \say{FunctionPtr}) , and one for the AST version of the method declaration that should be linked to the pointer. 

 \begin{lstlisting}
class StructVar(val name: String,
  val tpe: CType) extends StructMember {
  // some code
}

class StructFunctionPtr(val ptr: FunctionPtr,
  var mtDcl: MethodDecl) extends StructMember {
  // some code
}

class FunctionPtr(val name: String,
  val retType: CType, val args: List[CType]) {
  // some code
}
 \end{lstlisting}
 \subsubsection{Code Generation}
The second file is \say{COutputGeneration.scala}. Its skeleton and behavior is based on the \say{CodeGeneration.scala} completed
to output binary code for the Java Virtual Machine.
The program uses the same architecture of methods like: \say{cGenMethod}, \say{cGenStats}, \say{cGenExpr}.
Each of this method returns a \say{StringBuilder}.
\newline
The final is a .h and .c, which encloses all the StringBuilders concatened.
\newline
\paragraph{Inheritance}
\break

\paragraph{Dynamic dispatch}
Dynamic dispatch is accomplished during the default construction of a new Instance of a class. In tool, there is only on type of constructor, the default one. One idea we borrowed from our reference book\footnote{www.cs.rit.edu/~ats/books/ooc.pdf at page 11, si jamais faudra mettre ca dans la bibliography Ã  la fin scuse} was to have a default method be outputed called ``new'' which would take care or creating a new Instance of a struct and returning it as a generic pointer ``void *''. \textit{insert example code of new() here}

\paragraph{Method chaining}
\break
This problem was one, that we had not seen coming.
\newline
In Tool, there is the possibility to write multiple call to a method on one line.
It works because each method returns an object. We can't directly translate it in C programming language with the model we choosed to make object oriented possible. Our ``methods'' need to have as a first argument a pointer to the struct calling, so to make a method call on a struct we would need to write : \lstset{style=customc}{\lstinline[basicstyle=\small\ttfamily]|void * a = new(nA); ((struct A *) a)->foo(a)|}. Our variable a needs to be referenced two times, first to get the good function pointer and then as the first argument if ``foo'' need to access fields defined in A. Therefore chained method calls need intermediate variables to work correctly. 
To tackle this problem, we created a simple object: \say{tmpVarGen}.
\lstset{style=customscala}
\begin{lstlisting}
object tmpVarGen{
  private var counter = 0
    def getFreshVar: String = {
      counter += 1
      return "tmp"+counter
    }
    def getLastVar: String = "tmp"+counter
}
\end{lstlisting}
It is used to have a unique variable name. It has two methods.
\say{getLastVar} returns the last created variable name.
\say{getFreshVar} return a new variable name.
\newline
Now at each evaluation of an AST element, which is an expression, it is important first to evaluate the expressions
and assign to intermediate variables using the object \say{tmpVarGen}. Next the expression is written using
the variables.
\begin{lstlisting}
case Equals(lhs: ExprTree, rhs: ExprTree) =>
  val lhsString = cGenExpr(lhs)
  val lhsLastVar = tmpVarGen.getLastVar
  val rhsString = cGenExpr(rhs)
  val rhsLastVar = tmpVarGen.getLastVar
  val andExprResultVar = genTabulation(indentLvl)+
    CInt.toString()+" "+tmpVarGen.getFreshVar+" = "+
    lhsLastVar+" == "+rhsLastVar+";\n"
  return lhsString.append(rhsString).append(andExprResultVar)
\end{lstlisting}
Here it is an example with the evaluation of an expression AST element: Equals.
The left-hand side and right-hand side expressions are first evaulated using the \say{cGenExpr()} method and
are stored in intermediate variable using the \say{tmpVarGen} object.
Afterward the equal expression as known in C: \say{lhs == rhs} is written using the intermediate variable.
At the end we append all element together. Thus one Tool line to write an equality is
three lines in C programming language.
\newline
