This is a very important section, you explain to us how you made it work.

\subsection{Theoretical Background}
% TODO tu penses y mettre quelque chose?

\subsection{Implementation Details}
Two files were created to implement this project.
\subsubsection{Data Type}
The first one is \say{CDataType.scala}. It contains a class that depicts the C's structure.
\begin{lstlisting}
  class StructDef(val name: String,
    val membersList: ListBuffer[StructMember])
\end{lstlisting}
 A trait \say{StructMember} is extended by two class to implement the two sort of structure's members,
 which are a variable or a pointer to a function (as explained in section 2. Examples).
 Without forgetting to define a class \say{FunctionPtr}. It defines the fact that each function have as first parameter
 a generic pointer to the calling structure.
 \begin{lstlisting}
class StructVar(val name: String,
  val tpe: CType) extends StructMember {
  // some code
}

class StructFunctionPtr(val ptr: FunctionPtr,
  var mtDcl: MethodDecl) extends StructMember {
  // some code
}

class FunctionPtr(val name: String,
  val retType: CType, val args: List[CType]) {
  // some code
}
 \end{lstlisting}
 \subsubsection{Code Generation}
The second file is \say{COutputGeneration.scala}. Its skeleton and behavior is based on the \say{CodeGeneration.scala} completed
to output binary code for the Java Virtual Machine.
The program uses the same architecture of methods like: \say{cGenMethod}, \say{cGenStats}, \say{cGenExpr}.
Each of this method returns a \say{StringBuilder}.
\newline
The final is a .h and .c, which encloses all the StringBuilders concatened.
\newline
\paragraph{Inheritance}
\break

\paragraph{Dynamic dispatch}
\paragraph{Method chaining}
\break
This problem was one, that we had not seen coming.
\newline
In Tool, there is the possibility to write multiple call to a method on one line.
It works because each method returns an object. We can't directly translate it in C programming language.
To tackle this problem, we created a simple object: \say{tmpVarGen}.
\begin{lstlisting}
object tmpVarGen{
  private var counter = 0
    def getFreshVar: String = {
      counter += 1
      return "tmp"+counter
    }
    def getLastVar: String = "tmp"+counter
}
\end{lstlisting}
It is used to have a unique variable name. It has two methods.
\say{getLastVar} returns the last created variable name.
\say{getFreshVar} return a new variable name.
\newline
Now at each evaluation of an AST element, which is an expression, it is important first to evaluate the expressions
and assign to intermediate variables using the object \say{tmpVarGen}. Next the expression is written using
the variables.
\begin{lstlisting}
case Equals(lhs: ExprTree, rhs: ExprTree) =>
  val lhsString = cGenExpr(lhs)
  val lhsLastVar = tmpVarGen.getLastVar
  val rhsString = cGenExpr(rhs)
  val rhsLastVar = tmpVarGen.getLastVar
  val andExprResultVar = genTabulation(indentLvl)+
    CInt.toString()+" "+tmpVarGen.getFreshVar+" = "+
    lhsLastVar+" == "+rhsLastVar+";\n"
  return lhsString.append(rhsString).append(andExprResultVar)
\end{lstlisting}
Here it is an example with the evaluation of an expression AST element: Equals.
The left-hand side and right-hand side expressions are first evaulated using the \say{cGenExpr()} method and
are stored in intermediate variable using the \say{tmpVarGen} object.
Afterward the equal expression as known in C: \say{lhs == rhs} is written using the intermediate variable.
At the end we append all element together. Thus one Tool line to write an equality is
three lines in C programming language.
\newline
